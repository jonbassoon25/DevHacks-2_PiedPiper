<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>AZ Places — Swipe & Discover</title>
    <link rel="stylesheet" href="styles.css" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <main class="app">
      <header class="header">
        <div class="brand">
          <h1>AZ Places</h1>
          <p class="tagline">Find things to do in Arizona — swipe right to save</p>
        </div>
        <form id="search" class="search">
          <input id="location" placeholder="Location (e.g. Chandler, Arizona)" aria-label="location" />
          <input id="activity" placeholder="Activity (e.g. Hiking, Museum, Coffee)" aria-label="activity" />
          <button type="submit" class="btn primary">Go</button>
        </form>
      </header>

      <section id="viewport" class="viewport">
        <div id="stack" class="stack">
          <div class="notice">Enter a location and activity, then press Go</div>
        </div>
      </section>

      <div class="controls">
        <button id="rewind" class="circle">⟲</button>
        <button id="nope" class="circle no">✖</button>
        <button id="like" class="circle yes">❤</button>
      </div>

      <template id="cardTpl">
        <article class="card">
          <div class="badge-like">LIKE</div>
          <div class="badge-nope">NOPE</div>
          <div class="card__image"><img src="" alt=""/></div>
          <div class="card__info">
            <div class="meta"><span class="activity">Activity</span><span class="rating">★ <b class="score">4.5</b> <span class="count">(0)</span></span></div>
            <h2 class="name">Place Name</h2>
            <p class="location">Location</p>
            <p class="desc">Short description here...</p>
            <a class="source" target="_blank" rel="noopener">View source</a>
          </div>
        </article>
      </template>

      <script src="/socket.io/socket.io.js"></script>
      <script>
        const socket = io();
        const stack = document.getElementById('stack');
        const tpl = document.getElementById('cardTpl');
        const searchForm = document.getElementById('search');
        const locationInput = document.getElementById('location');
        const activityInput = document.getElementById('activity');
        const likeBtn = document.getElementById('like');
        const nopeBtn = document.getElementById('nope');
        const rewindBtn = document.getElementById('rewind');

        let history = [];

        function makeCard(row) {
          const node = tpl.content.cloneNode(true);
          const card = node.querySelector('.card');
          // store the raw row for later feedback events
          card.__place = row;
          const img = card.querySelector('img');
          img.src = row['URL'] ? row['URL'] : 'https://source.unsplash.com/600x400/?' + encodeURIComponent((row['Name']||'place').split(' ')[0]);
          img.alt = row['Name'] || 'place';
          card.querySelector('.activity').textContent = (row['Name']||'').split(' ')[0] || '';
          card.querySelector('.score').textContent = row['Rating'] || 'N/A';
          card.querySelector('.count').textContent = row['Reviews'] ? `(${row['Reviews']})` : '';
          card.querySelector('.name').textContent = row['Name'] || '';
          card.querySelector('.location').textContent = row['Location'] || '';
          card.querySelector('.desc').textContent = row['Description'] || '';
          const link = card.querySelector('.source');
          link.href = row['URL'] || '#';
          link.textContent = row['URL'] ? 'View source' : '';
          addDrag(card);
          return card;
        }

        function renderRows(rows, append = false) {
          if (!append) stack.innerHTML = '';
          if (!rows || !rows.length) {
            if (!append) stack.innerHTML = `<div class="notice">No results returned.</div>`;
            return;
          }
          for (let i = rows.length - 1; i >= 0; i--) {
            const c = makeCard(rows[i]);
            c.style.setProperty('--i', i);
            stack.appendChild(c);
          }
        }

        function addDrag(card) {
          let startX=0,startY=0,drag=false;
          let lastX = 0;
          function down(e){ drag=true; startX = e.clientX || e.touches?.[0]?.clientX; startY = e.clientY || e.touches?.[0]?.clientY; lastX = startX; card.classList.add('dragging'); card.style.transition = 'none'; }
          function move(e){ if(!drag) return; const x = (e.clientX||e.touches?.[0]?.clientX)-startX; const y = (e.clientY||e.touches?.[0]?.clientY)-startY; lastX = x; const rot = Math.max(Math.min(x/12, 25), -25); const scale = 1 - Math.min(Math.abs(x)/1500, 0.06); card.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg) scale(${scale})`; 
            // toggle badges
            if (x > 30) { card.classList.add('liking'); card.classList.remove('noping'); }
            else if (x < -30) { card.classList.add('noping'); card.classList.remove('liking'); }
            else { card.classList.remove('liking'); card.classList.remove('noping'); }
          }
          function up(e){ if(!drag) return; drag=false; card.classList.remove('dragging'); card.style.transition = ''; const endX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX) || 0; const delta = endX - startX; if(Math.abs(delta)>120){ const liked = delta>0; card.classList.remove('liking'); card.classList.remove('noping'); swipe(card, liked); } else { card.style.transform=''; card.classList.remove('liking'); card.classList.remove('noping'); } }
          card.addEventListener('pointerdown', down);
          window.addEventListener('pointermove', move);
          window.addEventListener('pointerup', up);
        }

        function swipe(card, liked){ 
          card.style.transition='transform 300ms ease, opacity 300ms'; 
          const dir = liked?1:-1; 
          card.style.transform=`translate(${dir*1000}px,-100px) rotate(${dir*30}deg)`; 
          card.style.opacity='0'; 
          history.push(card);
          // emit feedback over socket
          try {
            const payload = { action: liked ? 'like' : 'dislike', place: card.__place || null };
            socket.emit('user_feedback', payload);
          } catch (e) { console.warn('feedback emit failed', e); }
          setTimeout(()=>{ card.remove(); if(!stack.querySelector('.card')) stack.innerHTML=`<div class="notice">You're all caught up.</div>`; },350); 
        }

        likeBtn.addEventListener('click', ()=>{ const top = stack.querySelector('.card'); if(top) swipe(top, true); });
        nopeBtn.addEventListener('click', ()=>{ const top = stack.querySelector('.card'); if(top) swipe(top, false); });
        rewindBtn.addEventListener('click', ()=>{ const last = history.pop(); if(last){ last.style.opacity='1'; last.style.transform=''; stack.appendChild(last); } });

        // Emit the websocket request per your spec: event name _next_next_entries with an object containing key `count`.
        async function requestNext(count, location, activity) {
          return new Promise((resolve, reject) => {
            socket.emit('request_next_entries', { count: count, location: location || '', activity: activity || '' });
            // listen for several possible response event names (server may use different one)
            const handlers = {};
            const names = ['next_entries', '_next_next_entries_result', '_next_next_entries', 'response_next_entries', 'entries'];
            let settled = false;
            function done(data) {
              if (settled) return; settled = true;
              // cleanup
              names.forEach(n => socket.off(n, handlers[n]));
              resolve(data);
            }
            names.forEach(n => {
              handlers[n] = (payload) => { done(payload); };
              socket.on(n, handlers[n]);
            });
            // timeout
            setTimeout(()=>{
              if (!settled) {
                names.forEach(n => socket.off(n, handlers[n]));
                reject(new Error('Socket response timeout'));
              }
            }, 5000);
          });
        }

        searchForm.addEventListener('submit', async (e)=>{
          e.preventDefault();
          stack.innerHTML = `<div class="notice">Requesting results...</div>`;
          const loc = locationInput.value.trim();
          const act = activityInput.value.trim();
          try {
            const rows = await requestNext(12, loc, act);
            // server may send an object wrapper
            const data = Array.isArray(rows) ? rows : (rows && rows.results) ? rows.results : [];
            renderRows(data, false);
          } catch (err) {
            console.error(err);
            stack.innerHTML = `<div class="notice">Request failed — check server logs.</div>`;
          }
        });

        // when remaining cards low, request more
        const observer = new MutationObserver(async ()=>{
          const remaining = stack.querySelectorAll('.card').length;
          if (remaining <= 2) {
            const loc = locationInput.value.trim();
            const act = activityInput.value.trim();
            try {
              const rows = await requestNext(6, loc, act);
              const data = Array.isArray(rows) ? rows : (rows && rows.results) ? rows.results : [];
              renderRows(data, true);
            } catch (e) { console.warn('prefetch failed', e); }
          }
        });
        observer.observe(stack, { childList: true });
      </script>
    </main>
  </body>
</html>
