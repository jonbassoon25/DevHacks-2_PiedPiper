<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fynder ‚Äî Swipe & Discover</title>
    <link rel="stylesheet" href="styles.css" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  </head>
  <style>
    .user-block {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .dropdown {
    position: relative;
  }

  .dropdown-toggle {
    background: none;
    border: none;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-color, #fff);
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background: #fff;
    min-width: 120px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-radius: 6px;
    overflow: hidden;
    z-index: 1000;
  }

  .dropdown-menu a {
    display: block;
    padding: 8px 12px;
    color: #051124;
    text-decoration: none;
    font-size: 14px;
  }

  .dropdown-menu a:hover {
    background: var(--accent-1);
    color: #fff;
  }

  .dropdown:hover .dropdown-menu {
    display: block;
  }

  .saved-btn {
    margin-left: 12px;
    padding: 8px 10px;
  }
  </style>
  <!-- Floating Chat Widget -->
  <div id="chat-widget" class="chat-widget hidden">
  <div class="chat-header">
    <button id="chat-close" class="chat-close">‚úñ</button>
  </div>
  <iframe src="/agent.html" frameborder="0"></iframe>
  </div>

  <button id="chat-toggle" class="chat-toggle">
    üí¨
  </button>
  <script>
    const chatWidget = document.getElementById("chat-widget");
    const chatToggle = document.getElementById("chat-toggle");

    chatToggle.addEventListener("click", () => {
      chatWidget.classList.toggle("hidden");
    });
    const chatClose = document.getElementById("chat-close");

    chatClose.addEventListener("click", () => {
      chatWidget.classList.add("hidden");
    });
  </script>
  <body>
	<script src="/socket.io/socket.io.js"></script>
    <script>
	  const socket = io();
      // redirect to login if not authenticated (client-side simulated)
      try {
        const u = localStorage.getItem('az_user');
        if (!u || u === 'null') {
          if (!location.pathname.endsWith('/login.html')) location.replace('/login.html');
        } else {
			// send the server the user info
			socket.emit("user-info", u);
			console.log(u);
		}
      } catch(e){ console.log(e) }
    </script>
    <main class="app">
      <!-- logged-in bar will be inserted here -->
      <header class="header">
        <div id="userBlock" class="user-block">
        <!-- JS will populate user info + dropdown -->
        </div>
        <div class="brand">
          <h1>Fynder</h1>
          <p class="tagline">Discover places ‚Äî use Left/Right arrow keys to reject/save</p>
        </div>
        <div>
        <form id="search" class="search">
          <input id="location" placeholder="Location" aria-label="location" />
          <input id="activity" placeholder="Activity" aria-label="activity" />
          <button type="submit" class="btn primary">Go</button>
        </form></div>
      </header>

      <section id="viewport" class="viewport">
        <div id="stack" class="stack">
          <div class="notice">Enter a location and activity, then press Go</div>
        </div>
      </section>

      <div class="controls">
        <button id="rewind" class="circle">‚ü≤</button>
        <button id="nope" class="circle no">‚úñ</button>
        <button id="like" class="circle yes">‚ù§</button>
      </div>

      <template id="cardTpl">
        <article class="card">
          <div class="badge-like">LIKE</div>
          <div class="badge-nope">NOPE</div>
          <div class="card__image"><img src="" alt=""/></div>
          <div class="card__info">
            <div class="meta"><span class="activity">Activity</span><span class="rating">‚òÖ <b class="score">4.5</b> <span class="count">(0)</span></span></div>
            <h2 class="name">Place Name</h2>
            <p class="location">Location</p>
            <p class="desc">Short description here...</p>
            <a class="source" target="_blank" rel="noopener">View source</a>
          </div>
        </article>
      </template>

      <script>
        // populate user UI
        (function(){
          try{
            const raw = localStorage.getItem('az_user');
            const block = document.getElementById('userBlock');
            if (raw && block){
              const u = JSON.parse(raw);
              const img = document.createElement('div');
              img.style.width='36px';img.style.height='36px';img.style.borderRadius='999px';img.style.background='linear-gradient(90deg,var(--accent-1),var(--accent-2))';img.style.display='inline-flex';img.style.alignItems='center';img.style.justifyContent='center';img.style.color='#051124';img.style.fontWeight='700';img.textContent = (u.name||'U').split(' ').map(s=>s[0]).slice(0,2).join('');
              const name = document.createElement('div');name.style.fontWeight='600';name.style.fontSize='14px';name.textContent = u.name || 'User';
              block.appendChild(img);

              // dropdown wrapper
              const dropdown = document.createElement('div');
              dropdown.className = 'dropdown';

              // clickable profile name
              const nameBtn = document.createElement('button');
              nameBtn.className = 'dropdown-toggle';
              nameBtn.textContent = u.name || 'User';

              // dropdown content
              const menu = document.createElement('div');
              menu.className = 'dropdown-menu';

              // Saved item
              const savedItem = document.createElement('a');
              savedItem.href = '/saved.html';
              savedItem.textContent = 'Saved';
              menu.appendChild(savedItem);

              // Logout item
              const logoutItem = document.createElement('a');
              logoutItem.href = '#';
              logoutItem.textContent = 'Logout';
              logoutItem.addEventListener('click', (e) => {
                e.preventDefault();
                localStorage.removeItem('az_user');
                location.replace('/login.html');
              });
              menu.appendChild(logoutItem);
              dropdown.appendChild(nameBtn);
              dropdown.appendChild(menu);
              block.appendChild(dropdown);
            }
          }catch(e){/* noop */}
        })();

        const stack = document.getElementById('stack');
        const tpl = document.getElementById('cardTpl');
        const searchForm = document.getElementById('search');
        const locationInput = document.getElementById('location');
        const activityInput = document.getElementById('activity');
        const likeBtn = document.getElementById('like');
        const nopeBtn = document.getElementById('nope');
        const rewindBtn = document.getElementById('rewind');

        let history = [];

        function makeCard(row) {
          const node = tpl.content.cloneNode(true);
          const card = node.querySelector('.card');
          // store the raw row for later feedback events
          card.__place = row;
          const img = card.querySelector('img');
          img.src = row['URL'] ? row['URL'] : 'https://source.unsplash.com/600x400/?' + encodeURIComponent((row['Name']||'place').split(' ')[0]);
          img.alt = row['Name'] || 'place';
          card.querySelector('.activity').textContent = (row['Name']||'').split(' ')[0] || '';
          card.querySelector('.score').textContent = row['Rating'] || 'N/A';
          card.querySelector('.count').textContent = row['Reviews'] ? `(${row['Reviews']})` : '';
          card.querySelector('.name').textContent = row['Name'] || '';
          card.querySelector('.location').textContent = row['Location'] || '';
          card.querySelector('.desc').textContent = row['Description'] || '';
          const link = card.querySelector('.source');
          link.href = row['URL'] || '#';
          link.textContent = row['URL'] ? 'View source' : '';
          addDrag(card);
          return card;
        }

        function renderRows(rows, append = false) {
          if (!append) stack.innerHTML = '';
          if (!rows || !rows.length) {
            if (!append) stack.innerHTML = `<div class="notice">No results returned.</div>`;
            return;
          }
          // append new cards
          for (let i = rows.length - 1; i >= 0; i--) {
              const c = makeCard(rows[i]);
              stack.appendChild(c);
          }
          // enforce a maximum kept cards in DOM (keep latest N)
          const keepLast = 6;
          const all = Array.from(stack.querySelectorAll('.card'));
          // remove older cards if too many
          if (all.length > keepLast) {
            const removeCount = all.length - keepLast;
            for (let r = 0; r < removeCount; r++) {
              const rem = all[r];
              if (rem && rem.parentNode) rem.parentNode.removeChild(rem);
            }
          }
          // recompute indices and z-index for remaining cards
          const remaining = Array.from(stack.querySelectorAll('.card'));
          remaining.forEach((c, idx) => {
            // idx 0 is bottom, last is top
            const i = idx;
            c.style.setProperty('--i', i);
            c.style.zIndex = 1000 + (idx + 1);
            // ensure visible via opacity-based styling
            c.style.transition = 'opacity 260ms ease, transform 260ms ease';
          });
          updateStackVisibility();
        }

        // Shared drag state to avoid multiple global handlers and improve reliability
        let activeDrag = null; // { card, startX, startY, pointerId }

        function addDrag(card) {
          const imgArea = card.querySelector('.card__image');
          if (!imgArea) return;
          imgArea.addEventListener('pointerdown', (e) => {
            // start drag only when pressing on image area
            const startX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
            const startY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY) || 0;
            activeDrag = { card, startX, startY, pointerId: e.pointerId || null };
            card.classList.add('dragging');
            card.style.transition = 'none';
            try { if (e.pointerId && card.setPointerCapture) card.setPointerCapture(e.pointerId); } catch (err) {}
          });
        }

        // global move/up handlers operate on the single activeDrag
        window.addEventListener('pointermove', (e) => {
          if (!activeDrag) return;
          // ignore pointer events from other pointers
          if (activeDrag.pointerId != null && e.pointerId !== activeDrag.pointerId) return;
          const { card, startX, startY } = activeDrag;
          const x = (e.clientX || 0) - startX;
          const y = (e.clientY || 0) - startY;
          const rot = Math.max(Math.min(x/12, 25), -25);
          const scale = 1 - Math.min(Math.abs(x)/1500, 0.06);
          card.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg) scale(${scale})`;
          if (x > 30) { card.classList.add('liking'); card.classList.remove('noping'); }
          else if (x < -30) { card.classList.add('noping'); card.classList.remove('liking'); }
          else { card.classList.remove('liking'); card.classList.remove('noping'); }
        });

        function cancelActiveDrag(e) {
          if (!activeDrag) return;
          // if a pointerId exists, ensure we only cancel for that pointer
          if (activeDrag.pointerId != null && e && e.pointerId !== activeDrag.pointerId) return;
          const { card } = activeDrag;
          try { if (activeDrag.pointerId != null && card.releasePointerCapture) card.releasePointerCapture(activeDrag.pointerId); } catch (err) {}
          card.classList.remove('dragging');
          card.style.transition = '';
          card.style.transform = '';
          card.classList.remove('liking'); card.classList.remove('noping');
          activeDrag = null;
        }

        window.addEventListener('pointerup', (e) => {
          if (!activeDrag) return;
          if (activeDrag.pointerId != null && e.pointerId !== activeDrag.pointerId) return;
          const { card, startX } = activeDrag;
          const endX = e.clientX || 0;
          const delta = endX - startX;
          // release pointer capture
          try { if (activeDrag.pointerId != null && card.releasePointerCapture) card.releasePointerCapture(activeDrag.pointerId); } catch (err) {}
          card.classList.remove('dragging');
          card.style.transition = '';
          const threshold = 100;
          if (Math.abs(delta) > threshold) {
            const liked = delta > 0;
            card.classList.remove('liking'); card.classList.remove('noping');
            swipe(card, liked);
          } else {
            card.style.transform = '';
            card.classList.remove('liking'); card.classList.remove('noping');
          }
          activeDrag = null;
        });

        // cleanup handlers for cancelled pointers or lost capture
        window.addEventListener('pointercancel', cancelActiveDrag);
        window.addEventListener('lostpointercapture', cancelActiveDrag);

        function swipe(card, liked){ 
          card.style.transition='transform 300ms ease, opacity 300ms'; 
          const dir = liked?1:-1; 
          card.style.transform=`translate(${dir*1000}px,-100px) rotate(${dir*30}deg)`; 
          card.style.opacity='0'; 
          history.push(card);
          // emit feedback over socket
          try {
            const payload = { action: liked ? 'like' : 'dislike', place: card.__place || null };
            socket.emit('user_feedback', payload);
          } catch (e) { console.warn('feedback emit failed', e); }
          // persist liked places to localStorage
          if (liked && card.__place) {
            try{
              const key = 'fynder_saved';
              const raw = localStorage.getItem(key);
              const arr = raw ? JSON.parse(raw) : [];
              // dedupe by URL or Name
              const exists = arr.some(x => (x.URL && card.__place.URL && x.URL === card.__place.URL) || (x.Name && card.__place.Name && x.Name === card.__place.Name));
              if (!exists) {
                arr.push(card.__place);
                localStorage.setItem(key, JSON.stringify(arr));
              }
            }catch(e){console.warn('save failed', e)}
          }
          setTimeout(()=>{ 
            card.remove(); 
            // reveal the next top card
            // recompute indices and visibility after removal
            const remaining = Array.from(stack.querySelectorAll('.card'));
            remaining.forEach((c, idx) => {
              c.style.setProperty('--i', idx);
              c.style.zIndex = 1000 + (idx + 1);
            });
            updateStackVisibility();
            if(!stack.querySelector('.card')) stack.innerHTML=`<div class="notice">You're all caught up.</div>`; 
          },350); 
        }

  // (button handlers wired below using getTopCard)
  rewindBtn.addEventListener('click', ()=>{ const last = history.pop(); if(last){ last.style.opacity='1'; last.style.transform=''; stack.appendChild(last); updateStackVisibility(); } });

        // Helper to find the visible/top card (checks display and computed z-index)
        function getTopCard(){
          const cards = Array.from(stack.querySelectorAll('.card'));
          if (!cards.length) return null;
          // Prefer cards that are visible (not display:none)
          const vis = cards.filter(c => window.getComputedStyle(c).display !== 'none');
          const candidates = vis.length ? vis : cards;
          let top = null; let topZ = -Infinity;
          candidates.forEach(c => {
            const z = parseInt(window.getComputedStyle(c).zIndex || 0, 10);
            const val = Number.isFinite(z) ? z : 0;
            if (val > topZ) { topZ = val; top = c; }
          });
          if (!top) top = candidates[candidates.length - 1];
          return top;
        }

        // wire buttons to the actual top card
        likeBtn.addEventListener('click', ()=>{ const top = getTopCard(); if(top) swipe(top, true); });
        nopeBtn.addEventListener('click', ()=>{ const top = getTopCard(); if(top) swipe(top, false); });

        // keyboard controls: ArrowLeft = reject, ArrowRight = like
        window.addEventListener('keydown', (e) => {
          // ignore when user is typing in an input, textarea or contenteditable
          const tag = document.activeElement && document.activeElement.tagName;
          const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || document.activeElement.isContentEditable;
          if (isTyping) return;
          if (e.key === 'ArrowLeft') {
            const top = getTopCard(); if (top) swipe(top, false);
          } else if (e.key === 'ArrowRight') {
            const top = getTopCard(); if (top) swipe(top, true);
          }
        });

        // show only the top card, hide other articles inside the stack
        function updateStackVisibility(){
          const cards = Array.from(stack.querySelectorAll('.card'));
          if (!cards.length) return;
          // determine the card with the highest numeric z-index
          let top = null;
          let topZ = -Infinity;
          cards.forEach(c => {
            const z = parseInt(window.getComputedStyle(c).zIndex || 0, 10);
            if (!isFinite(z)) return;
            if (z > topZ) { topZ = z; top = c; }
          });
          // fallback to last card if computed z-index failed
          if (!top) top = cards[cards.length - 1];
          // hide all non-top cards completely
          cards.forEach(c => {
            if (c === top) {
              c.style.display = '';
              c.style.opacity = '1';
              c.style.pointerEvents = '';
              // restore the centered transform
              c.style.transform = `translate(-50%, calc(-50% + var(--offset-y))) scale(var(--offset-scale))`;
            } else {
              c.style.display = 'none';
              c.style.opacity = '0';
              c.style.pointerEvents = 'none';
            }
          });
        }

        // Observe style attribute changes on cards (so changes to z-index trigger visibility updates)
        const cardStyleObserver = new MutationObserver(muts => {
          let shouldUpdate = false;
          for (const m of muts) {
            if (m.type === 'attributes' && m.attributeName === 'style') {
              shouldUpdate = true; break;
            }
          }
          if (shouldUpdate) updateStackVisibility();
        });

        // observe existing cards and future additions
        const cardsRootObserver = new MutationObserver(muts => {
          for (const m of muts) {
            if (m.type === 'childList') {
              m.addedNodes.forEach(n => { if (n.nodeType === 1 && n.classList && n.classList.contains('card')) cardStyleObserver.observe(n, { attributes: true, attributeFilter: ['style'] }); });
              m.removedNodes.forEach(n => { if (n.nodeType === 1 && n.classList && n.classList.contains('card')) cardStyleObserver.disconnect(); });
            }
          }
        });
        // start observing the stack for added/removed cards
        cardsRootObserver.observe(stack, { childList: true });
        // attach observer to any currently existing cards
        Array.from(stack.querySelectorAll('.card')).forEach(c => cardStyleObserver.observe(c, { attributes: true, attributeFilter: ['style'] }));

        // Emit the websocket request per your spec: event name _next_next_entries with an object containing key `count`.
        async function requestNext(count, location, activity) {
          return new Promise((resolve, reject) => {
            socket.emit('request_next_entries', { count: count, location: location || '', activity: activity || '' });
            // listen for several possible response event names (server may use different one)
            const handlers = {};
            const names = ['next_entries', '_next_next_entries_result', '_next_next_entries', 'response_next_entries', 'entries'];
            let settled = false;
            function done(data) {
              if (settled) return; settled = true;
              // cleanup
              names.forEach(n => socket.off(n, handlers[n]));
              resolve(data);
            }
            names.forEach(n => {
              handlers[n] = (payload) => { done(payload); };
              socket.on(n, handlers[n]);
            });
            // timeout
            setTimeout(()=>{
              if (!settled) {
                names.forEach(n => socket.off(n, handlers[n]));
                reject(new Error('Socket response timeout'));
              }
            }, 5000);
          });
        }

        searchForm.addEventListener('submit', async (e)=>{
          e.preventDefault();
          stack.innerHTML = `<div class="notice">Requesting results...</div>`;
          const loc = locationInput.value.trim();
          const act = activityInput.value.trim();
          try {
            const rows = await requestNext(12, loc, act);
            // server may send an object wrapper
            const data = Array.isArray(rows) ? rows : (rows && rows.results) ? rows.results : [];
            renderRows(data, false);
          } catch (err) {
            console.error(err);
            stack.innerHTML = `<div class="notice">Request failed ‚Äî check server logs.</div>`;
          }
        });

		window.addEventListener('load', async (e)=>{
          e.preventDefault();
          stack.innerHTML = `<div class="notice">Requesting results...</div>`;
          const loc = locationInput.value.trim();
          const act = activityInput.value.trim();
          try {
            const rows = await requestNext(12, loc, act);
            // server may send an object wrapper
            const data = Array.isArray(rows) ? rows : (rows && rows.results) ? rows.results : [];
            renderRows(data, false);
          } catch (err) {
            console.error(err);
            stack.innerHTML = `<div class="notice">Request failed ‚Äî check server logs.</div>`;
          }
        });

        // when remaining cards low, request more
        const observer = new MutationObserver(async ()=>{
          const remaining = stack.querySelectorAll('.card').length;
          if (remaining <= 2) {
            const loc = locationInput.value.trim();
            const act = activityInput.value.trim();
            try {
              const rows = await requestNext(6, loc, act);
              const data = Array.isArray(rows) ? rows : (rows && rows.results) ? rows.results : [];
              renderRows(data, true);
            } catch (e) { console.warn('prefetch failed', e); }
          }
        });
        observer.observe(stack, { childList: true });
      </script>
    </main>

    <style>
      .chat-btn {
        position: fixed;
        bottom: 24px;
        right: 24px;
        width: 60px;
        height: 60px;
        background: linear-gradient(90deg, var(--accent-1), var(--accent-2));
        color: #051124;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 28px;
        text-decoration: none;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        z-index: 9999;
      }

      .chat-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 12px 32px rgba(0,0,0,0.4);
      }
    </style>
  </body>
</html>
